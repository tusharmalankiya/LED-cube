
LED-cube-atmel.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000822  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000074  00800060  00000822  00000896  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .comment      00000030  00000000  00000000  0000090a  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000093c  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000190  00000000  00000000  00000978  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001c34  00000000  00000000  00000b08  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000e63  00000000  00000000  0000273c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001387  00000000  00000000  0000359f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000002a4  00000000  00000000  00004928  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000005bf  00000000  00000000  00004bcc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001024  00000000  00000000  0000518b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000100  00000000  00000000  000061af  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 84 00 	jmp	0x108	; 0x108 <__vector_13>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e2 e2       	ldi	r30, 0x22	; 34
  68:	f8 e0       	ldi	r31, 0x08	; 8
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a4 3d       	cpi	r26, 0xD4	; 212
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	a4 ed       	ldi	r26, 0xD4	; 212
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a4 3d       	cpi	r26, 0xD4	; 212
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 ab 00 	call	0x156	; 0x156 <main>
  8a:	0c 94 0f 04 	jmp	0x81e	; 0x81e <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <reset_pins>:
#include "atmega32.h"

void reset_pins(void){
	//set layer pins off
	LAYER_PORT = 0b00000000;
  92:	1b ba       	out	0x1b, r1	; 27
	
	//set column pins on
	COLUMN_PORT = 0b11111111;
  94:	8f ef       	ldi	r24, 0xFF	; 255
  96:	88 bb       	out	0x18, r24	; 24
	ColUMN_LAST_PIN_PORT = 0b00000001;
  98:	81 e0       	ldi	r24, 0x01	; 1
  9a:	85 bb       	out	0x15, r24	; 21
  9c:	08 95       	ret

0000009e <initLEDs>:
	
}

// Function to initialize the LED cube pins
void initLEDs(void) {
	LAYER_DDR = LAYER_MASK; // Set layer pins as output
  9e:	87 e0       	ldi	r24, 0x07	; 7
  a0:	8a bb       	out	0x1a, r24	; 26
	
	COLUMN_DDR = COLUMN_MASK; // Set column pins as output
  a2:	8f ef       	ldi	r24, 0xFF	; 255
  a4:	87 bb       	out	0x17, r24	; 23
	ColUMN_LAST_PIN_DDR = COLUMN_LAST_PIN_MASK; // set 9th column pin as output
  a6:	81 e0       	ldi	r24, 0x01	; 1
  a8:	84 bb       	out	0x14, r24	; 20
	
	reset_pins();
  aa:	0e 94 49 00 	call	0x92	; 0x92 <reset_pins>
  ae:	08 95       	ret

000000b0 <USART_init>:
			break;
		}
		buffer[i++] = receivedChar;
	}
	buffer[i] = '\0';
}
  b0:	10 bc       	out	0x20, r1	; 32
  b2:	87 e6       	ldi	r24, 0x67	; 103
  b4:	89 b9       	out	0x09, r24	; 9
  b6:	88 e1       	ldi	r24, 0x18	; 24
  b8:	8a b9       	out	0x0a, r24	; 10
  ba:	86 e8       	ldi	r24, 0x86	; 134
  bc:	80 bd       	out	0x20, r24	; 32
  be:	08 95       	ret

000000c0 <USART_EnableRXInterrupt>:
  c0:	8a b1       	in	r24, 0x0a	; 10
  c2:	80 68       	ori	r24, 0x80	; 128
  c4:	8a b9       	out	0x0a, r24	; 10
  c6:	08 95       	ret

000000c8 <USART_transmit>:
  c8:	5d 9b       	sbis	0x0b, 5	; 11
  ca:	fe cf       	rjmp	.-4      	; 0xc8 <USART_transmit>
  cc:	8c b9       	out	0x0c, r24	; 12
  ce:	08 95       	ret

000000d0 <USART_transmit_string>:

void USART_transmit_string(const char* command){
  d0:	cf 93       	push	r28
  d2:	df 93       	push	r29
  d4:	ec 01       	movw	r28, r24
	while(*command != '\0'){
  d6:	03 c0       	rjmp	.+6      	; 0xde <USART_transmit_string+0xe>
		USART_transmit(*command);
  d8:	0e 94 64 00 	call	0xc8	; 0xc8 <USART_transmit>
		command++;
  dc:	21 96       	adiw	r28, 0x01	; 1
	}
	buffer[i] = '\0';
}

void USART_transmit_string(const char* command){
	while(*command != '\0'){
  de:	88 81       	ld	r24, Y
  e0:	81 11       	cpse	r24, r1
  e2:	fa cf       	rjmp	.-12     	; 0xd8 <USART_transmit_string+0x8>
		USART_transmit(*command);
		command++;
	}
	USART_transmit('\r');
  e4:	8d e0       	ldi	r24, 0x0D	; 13
  e6:	0e 94 64 00 	call	0xc8	; 0xc8 <USART_transmit>
	USART_transmit('\n');
  ea:	8a e0       	ldi	r24, 0x0A	; 10
  ec:	0e 94 64 00 	call	0xc8	; 0xc8 <USART_transmit>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  f0:	2f ef       	ldi	r18, 0xFF	; 255
  f2:	83 ed       	ldi	r24, 0xD3	; 211
  f4:	90 e3       	ldi	r25, 0x30	; 48
  f6:	21 50       	subi	r18, 0x01	; 1
  f8:	80 40       	sbci	r24, 0x00	; 0
  fa:	90 40       	sbci	r25, 0x00	; 0
  fc:	e1 f7       	brne	.-8      	; 0xf6 <USART_transmit_string+0x26>
  fe:	00 c0       	rjmp	.+0      	; 0x100 <USART_transmit_string+0x30>
 100:	00 00       	nop
	_delay_ms(1000);
}
 102:	df 91       	pop	r29
 104:	cf 91       	pop	r28
 106:	08 95       	ret

00000108 <__vector_13>:



//Interrupt Service Routine for USART receive interrupt. 
ISR(USART_RXC_vect) {
 108:	1f 92       	push	r1
 10a:	0f 92       	push	r0
 10c:	0f b6       	in	r0, 0x3f	; 63
 10e:	0f 92       	push	r0
 110:	11 24       	eor	r1, r1
 112:	2f 93       	push	r18
 114:	3f 93       	push	r19
 116:	4f 93       	push	r20
 118:	5f 93       	push	r21
 11a:	6f 93       	push	r22
 11c:	7f 93       	push	r23
 11e:	8f 93       	push	r24
 120:	9f 93       	push	r25
 122:	af 93       	push	r26
 124:	bf 93       	push	r27
 126:	ef 93       	push	r30
 128:	ff 93       	push	r31
	
	interrupt_data = UDR; // Fetch the received byte into the buffer
 12a:	8c b1       	in	r24, 0x0c	; 12
 12c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
	//interrupt_data = USART_receive();
	//char str[40];
	//UART_receive_string(str, 40);
	USART_transmit(interrupt_data);
 130:	0e 94 64 00 	call	0xc8	; 0xc8 <USART_transmit>
	//interrupt_data = str[0];
	//USART_transmit_string(str);
 134:	ff 91       	pop	r31
 136:	ef 91       	pop	r30
 138:	bf 91       	pop	r27
 13a:	af 91       	pop	r26
 13c:	9f 91       	pop	r25
 13e:	8f 91       	pop	r24
 140:	7f 91       	pop	r23
 142:	6f 91       	pop	r22
 144:	5f 91       	pop	r21
 146:	4f 91       	pop	r20
 148:	3f 91       	pop	r19
 14a:	2f 91       	pop	r18
 14c:	0f 90       	pop	r0
 14e:	0f be       	out	0x3f, r0	; 63
 150:	0f 90       	pop	r0
 152:	1f 90       	pop	r1
 154:	18 95       	reti

00000156 <main>:
//#include <string.h>



int main(void) {
	initLEDs(); // Initialize LED pins
 156:	0e 94 4f 00 	call	0x9e	; 0x9e <initLEDs>
	
	//initializing USART
	USART_init();
 15a:	0e 94 58 00 	call	0xb0	; 0xb0 <USART_init>
	
	USART_EnableRXInterrupt(); //enable interrupt
 15e:	0e 94 60 00 	call	0xc0	; 0xc0 <USART_EnableRXInterrupt>
	sei(); // Enable global interrupts
 162:	78 94       	sei
	
	//transmitting String
	USART_transmit_string("Start");
 164:	8d ec       	ldi	r24, 0xCD	; 205
 166:	90 e0       	ldi	r25, 0x00	; 0
 168:	0e 94 68 00 	call	0xd0	; 0xd0 <USART_transmit_string>
		//strcat(str, response);
		//transmitting String
		//USART_transmition_string(str);
		
		// Display each layer in sequence to create animation
		if(interrupt_data == '1'){
 16c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
 170:	81 33       	cpi	r24, 0x31	; 49
 172:	29 f4       	brne	.+10     	; 0x17e <main+0x28>
			pattern1();
 174:	0e 94 1f 01 	call	0x23e	; 0x23e <pattern1>
			pattern1_blink();
 178:	0e 94 36 01 	call	0x26c	; 0x26c <pattern1_blink>
 17c:	f7 cf       	rjmp	.-18     	; 0x16c <main+0x16>
		}
		else if(interrupt_data == '2'){
 17e:	82 33       	cpi	r24, 0x32	; 50
 180:	29 f4       	brne	.+10     	; 0x18c <main+0x36>
			pattern2();
 182:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <pattern2>
			pattern2_blink();
 186:	0e 94 bb 01 	call	0x376	; 0x376 <pattern2_blink>
 18a:	f0 cf       	rjmp	.-32     	; 0x16c <main+0x16>
		}
		else if(interrupt_data == '3'){
 18c:	83 33       	cpi	r24, 0x33	; 51
 18e:	29 f4       	brne	.+10     	; 0x19a <main+0x44>
			pattern3();
 190:	0e 94 ff 01 	call	0x3fe	; 0x3fe <pattern3>
			pattern3_blink();
 194:	0e 94 3f 02 	call	0x47e	; 0x47e <pattern3_blink>
 198:	e9 cf       	rjmp	.-46     	; 0x16c <main+0x16>
		}
		else if(interrupt_data == '4'){
 19a:	84 33       	cpi	r24, 0x34	; 52
 19c:	29 f4       	brne	.+10     	; 0x1a8 <main+0x52>
			pattern4();
 19e:	0e 94 82 02 	call	0x504	; 0x504 <pattern4>
			pattern4_blink();
 1a2:	0e 94 c2 02 	call	0x584	; 0x584 <pattern4_blink>
 1a6:	e2 cf       	rjmp	.-60     	; 0x16c <main+0x16>
		}
		else if(interrupt_data == '5'){
 1a8:	85 33       	cpi	r24, 0x35	; 53
 1aa:	29 f4       	brne	.+10     	; 0x1b6 <main+0x60>
			pattern5();
 1ac:	0e 94 05 03 	call	0x60a	; 0x60a <pattern5>
			pattern5_blink();
 1b0:	0e 94 46 03 	call	0x68c	; 0x68c <pattern5_blink>
 1b4:	db cf       	rjmp	.-74     	; 0x16c <main+0x16>
		}
		else if(interrupt_data == '6'){
 1b6:	86 33       	cpi	r24, 0x36	; 54
 1b8:	c9 f6       	brne	.-78     	; 0x16c <main+0x16>
			pattern6();
 1ba:	0e 94 8a 03 	call	0x714	; 0x714 <pattern6>
			pattern6_blink();
 1be:	0e 94 cb 03 	call	0x796	; 0x796 <pattern6_blink>
 1c2:	d4 cf       	rjmp	.-88     	; 0x16c <main+0x16>

000001c4 <displayLayer>:
	{0b10111111, 0b01111111, 0b11111111}, // Layer 2: All LEDs off
};

// Function to display a layer pattern
void displayLayer(uint8_t layer) {
	LAYER_PORT = (LAYER_PORT | ~LAYER_MASK) | (1 << layer); // Select the layer
 1c4:	9b b3       	in	r25, 0x1b	; 27
 1c6:	48 2f       	mov	r20, r24
 1c8:	50 e0       	ldi	r21, 0x00	; 0
 1ca:	21 e0       	ldi	r18, 0x01	; 1
 1cc:	30 e0       	ldi	r19, 0x00	; 0
 1ce:	08 2e       	mov	r0, r24
 1d0:	02 c0       	rjmp	.+4      	; 0x1d6 <displayLayer+0x12>
 1d2:	22 0f       	add	r18, r18
 1d4:	33 1f       	adc	r19, r19
 1d6:	0a 94       	dec	r0
 1d8:	e2 f7       	brpl	.-8      	; 0x1d2 <displayLayer+0xe>
 1da:	98 6f       	ori	r25, 0xF8	; 248
 1dc:	29 2b       	or	r18, r25
 1de:	2b bb       	out	0x1b, r18	; 27
	
	// Output the pattern for the selected layer
	for (int i = 0; i < 3; i++) {
 1e0:	20 e0       	ldi	r18, 0x00	; 0
 1e2:	30 e0       	ldi	r19, 0x00	; 0
 1e4:	28 c0       	rjmp	.+80     	; 0x236 <displayLayer+0x72>
		if(i == 2 && layer == 2){
 1e6:	22 30       	cpi	r18, 0x02	; 2
 1e8:	31 05       	cpc	r19, r1
 1ea:	79 f4       	brne	.+30     	; 0x20a <displayLayer+0x46>
 1ec:	82 30       	cpi	r24, 0x02	; 2
 1ee:	69 f4       	brne	.+26     	; 0x20a <displayLayer+0x46>
			ColUMN_LAST_PIN_PORT &= ~(1 << PINC0);
 1f0:	95 b3       	in	r25, 0x15	; 21
 1f2:	9e 7f       	andi	r25, 0xFE	; 254
 1f4:	95 bb       	out	0x15, r25	; 21
 1f6:	6f ef       	ldi	r22, 0xFF	; 255
 1f8:	71 ee       	ldi	r23, 0xE1	; 225
 1fa:	94 e0       	ldi	r25, 0x04	; 4
 1fc:	61 50       	subi	r22, 0x01	; 1
 1fe:	70 40       	sbci	r23, 0x00	; 0
 200:	90 40       	sbci	r25, 0x00	; 0
 202:	e1 f7       	brne	.-8      	; 0x1fc <displayLayer+0x38>
 204:	00 c0       	rjmp	.+0      	; 0x206 <displayLayer+0x42>
 206:	00 00       	nop
			_delay_ms(100);
			continue;
 208:	14 c0       	rjmp	.+40     	; 0x232 <displayLayer+0x6e>
		}
		COLUMN_PORT = patterns1[layer][i];
 20a:	fa 01       	movw	r30, r20
 20c:	ee 0f       	add	r30, r30
 20e:	ff 1f       	adc	r31, r31
 210:	e4 0f       	add	r30, r20
 212:	f5 1f       	adc	r31, r21
 214:	e6 59       	subi	r30, 0x96	; 150
 216:	ff 4f       	sbci	r31, 0xFF	; 255
 218:	e2 0f       	add	r30, r18
 21a:	f3 1f       	adc	r31, r19
 21c:	90 81       	ld	r25, Z
 21e:	98 bb       	out	0x18, r25	; 24
 220:	6f ef       	ldi	r22, 0xFF	; 255
 222:	71 ee       	ldi	r23, 0xE1	; 225
 224:	94 e0       	ldi	r25, 0x04	; 4
 226:	61 50       	subi	r22, 0x01	; 1
 228:	70 40       	sbci	r23, 0x00	; 0
 22a:	90 40       	sbci	r25, 0x00	; 0
 22c:	e1 f7       	brne	.-8      	; 0x226 <displayLayer+0x62>
 22e:	00 c0       	rjmp	.+0      	; 0x230 <displayLayer+0x6c>
 230:	00 00       	nop
// Function to display a layer pattern
void displayLayer(uint8_t layer) {
	LAYER_PORT = (LAYER_PORT | ~LAYER_MASK) | (1 << layer); // Select the layer
	
	// Output the pattern for the selected layer
	for (int i = 0; i < 3; i++) {
 232:	2f 5f       	subi	r18, 0xFF	; 255
 234:	3f 4f       	sbci	r19, 0xFF	; 255
 236:	23 30       	cpi	r18, 0x03	; 3
 238:	31 05       	cpc	r19, r1
 23a:	ac f2       	brlt	.-86     	; 0x1e6 <displayLayer+0x22>
			continue;
		}
		COLUMN_PORT = patterns1[layer][i];
		_delay_ms(100); // Adjust the delay as needed for brightness
	}
}
 23c:	08 95       	ret

0000023e <pattern1>:

void pattern1(void){
 23e:	cf 93       	push	r28
 240:	df 93       	push	r29
	for (int layer = 0; layer < 3; layer++) {
 242:	c0 e0       	ldi	r28, 0x00	; 0
 244:	d0 e0       	ldi	r29, 0x00	; 0
 246:	0a c0       	rjmp	.+20     	; 0x25c <pattern1+0x1e>
		displayLayer(layer);
 248:	8c 2f       	mov	r24, r28
 24a:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <displayLayer>
 24e:	8f e9       	ldi	r24, 0x9F	; 159
 250:	9f e0       	ldi	r25, 0x0F	; 15
 252:	01 97       	sbiw	r24, 0x01	; 1
 254:	f1 f7       	brne	.-4      	; 0x252 <pattern1+0x14>
 256:	00 c0       	rjmp	.+0      	; 0x258 <pattern1+0x1a>
 258:	00 00       	nop
		_delay_ms(100); // Adjust the delay as needed for brightness
	}
}

void pattern1(void){
	for (int layer = 0; layer < 3; layer++) {
 25a:	21 96       	adiw	r28, 0x01	; 1
 25c:	c3 30       	cpi	r28, 0x03	; 3
 25e:	d1 05       	cpc	r29, r1
 260:	9c f3       	brlt	.-26     	; 0x248 <pattern1+0xa>
		displayLayer(layer);
		_delay_ms(1); // Adjust the delay to control animation speed
	}
	reset_pins();
 262:	0e 94 49 00 	call	0x92	; 0x92 <reset_pins>

}
 266:	df 91       	pop	r29
 268:	cf 91       	pop	r28
 26a:	08 95       	ret

0000026c <pattern1_blink>:

void pattern1_blink(void){
	for (int j = 0; j < 3; j++) {
 26c:	20 e0       	ldi	r18, 0x00	; 0
 26e:	30 e0       	ldi	r19, 0x00	; 0
 270:	3b c0       	rjmp	.+118    	; 0x2e8 <pattern1_blink+0x7c>
		LAYER_PORT = 0b00000111;
 272:	87 e0       	ldi	r24, 0x07	; 7
 274:	8b bb       	out	0x1b, r24	; 27
		
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 276:	80 e0       	ldi	r24, 0x00	; 0
 278:	90 e0       	ldi	r25, 0x00	; 0
 27a:	2b c0       	rjmp	.+86     	; 0x2d2 <pattern1_blink+0x66>
			if(i == 2 && j == 2){
 27c:	82 30       	cpi	r24, 0x02	; 2
 27e:	91 05       	cpc	r25, r1
 280:	99 f4       	brne	.+38     	; 0x2a8 <pattern1_blink+0x3c>
 282:	22 30       	cpi	r18, 0x02	; 2
 284:	31 05       	cpc	r19, r1
 286:	81 f4       	brne	.+32     	; 0x2a8 <pattern1_blink+0x3c>
				ColUMN_LAST_PIN_PORT &= ~(1 << PINC0);
 288:	45 b3       	in	r20, 0x15	; 21
 28a:	4e 7f       	andi	r20, 0xFE	; 254
 28c:	45 bb       	out	0x15, r20	; 21
 28e:	4f ef       	ldi	r20, 0xFF	; 255
 290:	51 ee       	ldi	r21, 0xE1	; 225
 292:	64 e0       	ldi	r22, 0x04	; 4
 294:	41 50       	subi	r20, 0x01	; 1
 296:	50 40       	sbci	r21, 0x00	; 0
 298:	60 40       	sbci	r22, 0x00	; 0
 29a:	e1 f7       	brne	.-8      	; 0x294 <pattern1_blink+0x28>
 29c:	00 c0       	rjmp	.+0      	; 0x29e <pattern1_blink+0x32>
 29e:	00 00       	nop
				_delay_ms(100);
				ColUMN_LAST_PIN_PORT |= (1 << PINC0);
 2a0:	45 b3       	in	r20, 0x15	; 21
 2a2:	41 60       	ori	r20, 0x01	; 1
 2a4:	45 bb       	out	0x15, r20	; 21
				continue;
 2a6:	14 c0       	rjmp	.+40     	; 0x2d0 <pattern1_blink+0x64>
			}
			COLUMN_PORT = patterns1_blink[j][i];
 2a8:	f9 01       	movw	r30, r18
 2aa:	ee 0f       	add	r30, r30
 2ac:	ff 1f       	adc	r31, r31
 2ae:	e2 0f       	add	r30, r18
 2b0:	f3 1f       	adc	r31, r19
 2b2:	ef 59       	subi	r30, 0x9F	; 159
 2b4:	ff 4f       	sbci	r31, 0xFF	; 255
 2b6:	e8 0f       	add	r30, r24
 2b8:	f9 1f       	adc	r31, r25
 2ba:	40 81       	ld	r20, Z
 2bc:	48 bb       	out	0x18, r20	; 24
 2be:	4f ef       	ldi	r20, 0xFF	; 255
 2c0:	51 ee       	ldi	r21, 0xE1	; 225
 2c2:	64 e0       	ldi	r22, 0x04	; 4
 2c4:	41 50       	subi	r20, 0x01	; 1
 2c6:	50 40       	sbci	r21, 0x00	; 0
 2c8:	60 40       	sbci	r22, 0x00	; 0
 2ca:	e1 f7       	brne	.-8      	; 0x2c4 <pattern1_blink+0x58>
 2cc:	00 c0       	rjmp	.+0      	; 0x2ce <pattern1_blink+0x62>
 2ce:	00 00       	nop
void pattern1_blink(void){
	for (int j = 0; j < 3; j++) {
		LAYER_PORT = 0b00000111;
		
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 2d0:	01 96       	adiw	r24, 0x01	; 1
 2d2:	83 30       	cpi	r24, 0x03	; 3
 2d4:	91 05       	cpc	r25, r1
 2d6:	94 f2       	brlt	.-92     	; 0x27c <pattern1_blink+0x10>
 2d8:	8f e9       	ldi	r24, 0x9F	; 159
 2da:	9f e0       	ldi	r25, 0x0F	; 15
 2dc:	01 97       	sbiw	r24, 0x01	; 1
 2de:	f1 f7       	brne	.-4      	; 0x2dc <pattern1_blink+0x70>
 2e0:	00 c0       	rjmp	.+0      	; 0x2e2 <pattern1_blink+0x76>
 2e2:	00 00       	nop
	reset_pins();

}

void pattern1_blink(void){
	for (int j = 0; j < 3; j++) {
 2e4:	2f 5f       	subi	r18, 0xFF	; 255
 2e6:	3f 4f       	sbci	r19, 0xFF	; 255
 2e8:	23 30       	cpi	r18, 0x03	; 3
 2ea:	31 05       	cpc	r19, r1
 2ec:	14 f2       	brlt	.-124    	; 0x272 <pattern1_blink+0x6>
			COLUMN_PORT = patterns1_blink[j][i];
			_delay_ms(100); // Adjust the delay as needed for brightness
		}
		_delay_ms(1); // Adjust the delay to control animation speed
	}
	reset_pins();
 2ee:	0e 94 49 00 	call	0x92	; 0x92 <reset_pins>
 2f2:	08 95       	ret

000002f4 <pattern2>:
	{0b11111011, 0b11011111, 0b11111111}, // Layer 2: All LEDs off
};


void pattern2(void){
	for (int j = 0; j < 3; j++) {
 2f4:	20 e0       	ldi	r18, 0x00	; 0
 2f6:	30 e0       	ldi	r19, 0x00	; 0
 2f8:	38 c0       	rjmp	.+112    	; 0x36a <pattern2+0x76>
		LAYER_PORT = 0b00000111;
 2fa:	87 e0       	ldi	r24, 0x07	; 7
 2fc:	8b bb       	out	0x1b, r24	; 27
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 2fe:	80 e0       	ldi	r24, 0x00	; 0
 300:	90 e0       	ldi	r25, 0x00	; 0
 302:	28 c0       	rjmp	.+80     	; 0x354 <pattern2+0x60>
			if(i == 2 && j == 2){
 304:	82 30       	cpi	r24, 0x02	; 2
 306:	91 05       	cpc	r25, r1
 308:	81 f4       	brne	.+32     	; 0x32a <pattern2+0x36>
 30a:	22 30       	cpi	r18, 0x02	; 2
 30c:	31 05       	cpc	r19, r1
 30e:	69 f4       	brne	.+26     	; 0x32a <pattern2+0x36>
				ColUMN_LAST_PIN_PORT &= ~(1 << PINC0);
 310:	45 b3       	in	r20, 0x15	; 21
 312:	4e 7f       	andi	r20, 0xFE	; 254
 314:	45 bb       	out	0x15, r20	; 21
 316:	4f ef       	ldi	r20, 0xFF	; 255
 318:	51 ee       	ldi	r21, 0xE1	; 225
 31a:	64 e0       	ldi	r22, 0x04	; 4
 31c:	41 50       	subi	r20, 0x01	; 1
 31e:	50 40       	sbci	r21, 0x00	; 0
 320:	60 40       	sbci	r22, 0x00	; 0
 322:	e1 f7       	brne	.-8      	; 0x31c <pattern2+0x28>
 324:	00 c0       	rjmp	.+0      	; 0x326 <pattern2+0x32>
 326:	00 00       	nop
				_delay_ms(100);
				continue;
 328:	14 c0       	rjmp	.+40     	; 0x352 <pattern2+0x5e>
			}
			COLUMN_PORT = patterns2[j][i];
 32a:	f9 01       	movw	r30, r18
 32c:	ee 0f       	add	r30, r30
 32e:	ff 1f       	adc	r31, r31
 330:	e2 0f       	add	r30, r18
 332:	f3 1f       	adc	r31, r19
 334:	e4 58       	subi	r30, 0x84	; 132
 336:	ff 4f       	sbci	r31, 0xFF	; 255
 338:	e8 0f       	add	r30, r24
 33a:	f9 1f       	adc	r31, r25
 33c:	40 81       	ld	r20, Z
 33e:	48 bb       	out	0x18, r20	; 24
 340:	4f ef       	ldi	r20, 0xFF	; 255
 342:	51 ee       	ldi	r21, 0xE1	; 225
 344:	64 e0       	ldi	r22, 0x04	; 4
 346:	41 50       	subi	r20, 0x01	; 1
 348:	50 40       	sbci	r21, 0x00	; 0
 34a:	60 40       	sbci	r22, 0x00	; 0
 34c:	e1 f7       	brne	.-8      	; 0x346 <pattern2+0x52>
 34e:	00 c0       	rjmp	.+0      	; 0x350 <pattern2+0x5c>
 350:	00 00       	nop

void pattern2(void){
	for (int j = 0; j < 3; j++) {
		LAYER_PORT = 0b00000111;
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 352:	01 96       	adiw	r24, 0x01	; 1
 354:	83 30       	cpi	r24, 0x03	; 3
 356:	91 05       	cpc	r25, r1
 358:	ac f2       	brlt	.-86     	; 0x304 <pattern2+0x10>
 35a:	8f e9       	ldi	r24, 0x9F	; 159
 35c:	9f e0       	ldi	r25, 0x0F	; 15
 35e:	01 97       	sbiw	r24, 0x01	; 1
 360:	f1 f7       	brne	.-4      	; 0x35e <pattern2+0x6a>
 362:	00 c0       	rjmp	.+0      	; 0x364 <pattern2+0x70>
 364:	00 00       	nop
	{0b11111011, 0b11011111, 0b11111111}, // Layer 2: All LEDs off
};


void pattern2(void){
	for (int j = 0; j < 3; j++) {
 366:	2f 5f       	subi	r18, 0xFF	; 255
 368:	3f 4f       	sbci	r19, 0xFF	; 255
 36a:	23 30       	cpi	r18, 0x03	; 3
 36c:	31 05       	cpc	r19, r1
 36e:	2c f2       	brlt	.-118    	; 0x2fa <pattern2+0x6>
			COLUMN_PORT = patterns2[j][i];
			_delay_ms(100); // Adjust the delay as needed for brightness
		}
		_delay_ms(1); // Adjust the delay to control animation speed
	}
	reset_pins();
 370:	0e 94 49 00 	call	0x92	; 0x92 <reset_pins>
 374:	08 95       	ret

00000376 <pattern2_blink>:
}

void pattern2_blink(void){
	for (int j = 0; j < 3; j++) {
 376:	20 e0       	ldi	r18, 0x00	; 0
 378:	30 e0       	ldi	r19, 0x00	; 0
 37a:	3b c0       	rjmp	.+118    	; 0x3f2 <pattern2_blink+0x7c>
		LAYER_PORT = 0b00000111;
 37c:	87 e0       	ldi	r24, 0x07	; 7
 37e:	8b bb       	out	0x1b, r24	; 27
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 380:	80 e0       	ldi	r24, 0x00	; 0
 382:	90 e0       	ldi	r25, 0x00	; 0
 384:	2b c0       	rjmp	.+86     	; 0x3dc <pattern2_blink+0x66>
			if(i == 2 && j == 2){
 386:	82 30       	cpi	r24, 0x02	; 2
 388:	91 05       	cpc	r25, r1
 38a:	99 f4       	brne	.+38     	; 0x3b2 <pattern2_blink+0x3c>
 38c:	22 30       	cpi	r18, 0x02	; 2
 38e:	31 05       	cpc	r19, r1
 390:	81 f4       	brne	.+32     	; 0x3b2 <pattern2_blink+0x3c>
				ColUMN_LAST_PIN_PORT &= ~(1 << PINC0);
 392:	45 b3       	in	r20, 0x15	; 21
 394:	4e 7f       	andi	r20, 0xFE	; 254
 396:	45 bb       	out	0x15, r20	; 21
 398:	4f ef       	ldi	r20, 0xFF	; 255
 39a:	51 ee       	ldi	r21, 0xE1	; 225
 39c:	64 e0       	ldi	r22, 0x04	; 4
 39e:	41 50       	subi	r20, 0x01	; 1
 3a0:	50 40       	sbci	r21, 0x00	; 0
 3a2:	60 40       	sbci	r22, 0x00	; 0
 3a4:	e1 f7       	brne	.-8      	; 0x39e <pattern2_blink+0x28>
 3a6:	00 c0       	rjmp	.+0      	; 0x3a8 <pattern2_blink+0x32>
 3a8:	00 00       	nop
				_delay_ms(100);
				ColUMN_LAST_PIN_PORT |= (1 << PINC0);
 3aa:	45 b3       	in	r20, 0x15	; 21
 3ac:	41 60       	ori	r20, 0x01	; 1
 3ae:	45 bb       	out	0x15, r20	; 21
				continue;
 3b0:	14 c0       	rjmp	.+40     	; 0x3da <pattern2_blink+0x64>
			}
			COLUMN_PORT = patterns2_blink[j][i];
 3b2:	f9 01       	movw	r30, r18
 3b4:	ee 0f       	add	r30, r30
 3b6:	ff 1f       	adc	r31, r31
 3b8:	e2 0f       	add	r30, r18
 3ba:	f3 1f       	adc	r31, r19
 3bc:	ed 58       	subi	r30, 0x8D	; 141
 3be:	ff 4f       	sbci	r31, 0xFF	; 255
 3c0:	e8 0f       	add	r30, r24
 3c2:	f9 1f       	adc	r31, r25
 3c4:	40 81       	ld	r20, Z
 3c6:	48 bb       	out	0x18, r20	; 24
 3c8:	4f ef       	ldi	r20, 0xFF	; 255
 3ca:	51 ee       	ldi	r21, 0xE1	; 225
 3cc:	64 e0       	ldi	r22, 0x04	; 4
 3ce:	41 50       	subi	r20, 0x01	; 1
 3d0:	50 40       	sbci	r21, 0x00	; 0
 3d2:	60 40       	sbci	r22, 0x00	; 0
 3d4:	e1 f7       	brne	.-8      	; 0x3ce <pattern2_blink+0x58>
 3d6:	00 c0       	rjmp	.+0      	; 0x3d8 <pattern2_blink+0x62>
 3d8:	00 00       	nop

void pattern2_blink(void){
	for (int j = 0; j < 3; j++) {
		LAYER_PORT = 0b00000111;
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 3da:	01 96       	adiw	r24, 0x01	; 1
 3dc:	83 30       	cpi	r24, 0x03	; 3
 3de:	91 05       	cpc	r25, r1
 3e0:	94 f2       	brlt	.-92     	; 0x386 <pattern2_blink+0x10>
 3e2:	8f e9       	ldi	r24, 0x9F	; 159
 3e4:	9f e0       	ldi	r25, 0x0F	; 15
 3e6:	01 97       	sbiw	r24, 0x01	; 1
 3e8:	f1 f7       	brne	.-4      	; 0x3e6 <pattern2_blink+0x70>
 3ea:	00 c0       	rjmp	.+0      	; 0x3ec <pattern2_blink+0x76>
 3ec:	00 00       	nop
	}
	reset_pins();
}

void pattern2_blink(void){
	for (int j = 0; j < 3; j++) {
 3ee:	2f 5f       	subi	r18, 0xFF	; 255
 3f0:	3f 4f       	sbci	r19, 0xFF	; 255
 3f2:	23 30       	cpi	r18, 0x03	; 3
 3f4:	31 05       	cpc	r19, r1
 3f6:	14 f2       	brlt	.-124    	; 0x37c <pattern2_blink+0x6>
			COLUMN_PORT = patterns2_blink[j][i];
			_delay_ms(100); // Adjust the delay as needed for brightness
		}
		_delay_ms(1); // Adjust the delay to control animation speed
	}
	reset_pins();
 3f8:	0e 94 49 00 	call	0x92	; 0x92 <reset_pins>
 3fc:	08 95       	ret

000003fe <pattern3>:
	{0b10111111, 0b11110111, 0b11111110}, // Layer 2: All LEDs off
};


void pattern3(void){
	for (int j = 0; j < 3; j++) {
 3fe:	20 e0       	ldi	r18, 0x00	; 0
 400:	30 e0       	ldi	r19, 0x00	; 0
 402:	37 c0       	rjmp	.+110    	; 0x472 <__EEPROM_REGION_LENGTH__+0x72>
		LAYER_PORT = 0b00000111;
 404:	87 e0       	ldi	r24, 0x07	; 7
 406:	8b bb       	out	0x1b, r24	; 27
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 408:	80 e0       	ldi	r24, 0x00	; 0
 40a:	90 e0       	ldi	r25, 0x00	; 0
 40c:	27 c0       	rjmp	.+78     	; 0x45c <__EEPROM_REGION_LENGTH__+0x5c>
			if(i == 0 && j == 0){
 40e:	00 97       	sbiw	r24, 0x00	; 0
 410:	81 f4       	brne	.+32     	; 0x432 <__EEPROM_REGION_LENGTH__+0x32>
 412:	21 15       	cp	r18, r1
 414:	31 05       	cpc	r19, r1
 416:	69 f4       	brne	.+26     	; 0x432 <__EEPROM_REGION_LENGTH__+0x32>
				ColUMN_LAST_PIN_PORT &= ~(1 << PINC0);
 418:	45 b3       	in	r20, 0x15	; 21
 41a:	4e 7f       	andi	r20, 0xFE	; 254
 41c:	45 bb       	out	0x15, r20	; 21
 41e:	4f ef       	ldi	r20, 0xFF	; 255
 420:	51 ee       	ldi	r21, 0xE1	; 225
 422:	64 e0       	ldi	r22, 0x04	; 4
 424:	41 50       	subi	r20, 0x01	; 1
 426:	50 40       	sbci	r21, 0x00	; 0
 428:	60 40       	sbci	r22, 0x00	; 0
 42a:	e1 f7       	brne	.-8      	; 0x424 <__EEPROM_REGION_LENGTH__+0x24>
 42c:	00 c0       	rjmp	.+0      	; 0x42e <__EEPROM_REGION_LENGTH__+0x2e>
 42e:	00 00       	nop
				_delay_ms(100);
				continue;
 430:	14 c0       	rjmp	.+40     	; 0x45a <__EEPROM_REGION_LENGTH__+0x5a>
			}
			COLUMN_PORT = patterns3[j][i];
 432:	f9 01       	movw	r30, r18
 434:	ee 0f       	add	r30, r30
 436:	ff 1f       	adc	r31, r31
 438:	e2 0f       	add	r30, r18
 43a:	f3 1f       	adc	r31, r19
 43c:	e2 57       	subi	r30, 0x72	; 114
 43e:	ff 4f       	sbci	r31, 0xFF	; 255
 440:	e8 0f       	add	r30, r24
 442:	f9 1f       	adc	r31, r25
 444:	40 81       	ld	r20, Z
 446:	48 bb       	out	0x18, r20	; 24
 448:	4f ef       	ldi	r20, 0xFF	; 255
 44a:	51 ee       	ldi	r21, 0xE1	; 225
 44c:	64 e0       	ldi	r22, 0x04	; 4
 44e:	41 50       	subi	r20, 0x01	; 1
 450:	50 40       	sbci	r21, 0x00	; 0
 452:	60 40       	sbci	r22, 0x00	; 0
 454:	e1 f7       	brne	.-8      	; 0x44e <__EEPROM_REGION_LENGTH__+0x4e>
 456:	00 c0       	rjmp	.+0      	; 0x458 <__EEPROM_REGION_LENGTH__+0x58>
 458:	00 00       	nop

void pattern3(void){
	for (int j = 0; j < 3; j++) {
		LAYER_PORT = 0b00000111;
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 45a:	01 96       	adiw	r24, 0x01	; 1
 45c:	83 30       	cpi	r24, 0x03	; 3
 45e:	91 05       	cpc	r25, r1
 460:	b4 f2       	brlt	.-84     	; 0x40e <__EEPROM_REGION_LENGTH__+0xe>
 462:	8f e9       	ldi	r24, 0x9F	; 159
 464:	9f e0       	ldi	r25, 0x0F	; 15
 466:	01 97       	sbiw	r24, 0x01	; 1
 468:	f1 f7       	brne	.-4      	; 0x466 <__EEPROM_REGION_LENGTH__+0x66>
 46a:	00 c0       	rjmp	.+0      	; 0x46c <__EEPROM_REGION_LENGTH__+0x6c>
 46c:	00 00       	nop
	{0b10111111, 0b11110111, 0b11111110}, // Layer 2: All LEDs off
};


void pattern3(void){
	for (int j = 0; j < 3; j++) {
 46e:	2f 5f       	subi	r18, 0xFF	; 255
 470:	3f 4f       	sbci	r19, 0xFF	; 255
 472:	23 30       	cpi	r18, 0x03	; 3
 474:	31 05       	cpc	r19, r1
 476:	34 f2       	brlt	.-116    	; 0x404 <__EEPROM_REGION_LENGTH__+0x4>
			COLUMN_PORT = patterns3[j][i];
			_delay_ms(100); // Adjust the delay as needed for brightness
		}
		_delay_ms(1); // Adjust the delay to control animation speed
	}
	reset_pins();
 478:	0e 94 49 00 	call	0x92	; 0x92 <reset_pins>
 47c:	08 95       	ret

0000047e <pattern3_blink>:

}

void pattern3_blink(void){
	for (int j = 0; j < 3; j++) {
 47e:	20 e0       	ldi	r18, 0x00	; 0
 480:	30 e0       	ldi	r19, 0x00	; 0
 482:	3a c0       	rjmp	.+116    	; 0x4f8 <pattern3_blink+0x7a>
		LAYER_PORT = 0b00000111;
 484:	87 e0       	ldi	r24, 0x07	; 7
 486:	8b bb       	out	0x1b, r24	; 27
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 488:	80 e0       	ldi	r24, 0x00	; 0
 48a:	90 e0       	ldi	r25, 0x00	; 0
 48c:	2a c0       	rjmp	.+84     	; 0x4e2 <pattern3_blink+0x64>
			if(i == 0 && j == 0){
 48e:	00 97       	sbiw	r24, 0x00	; 0
 490:	99 f4       	brne	.+38     	; 0x4b8 <pattern3_blink+0x3a>
 492:	21 15       	cp	r18, r1
 494:	31 05       	cpc	r19, r1
 496:	81 f4       	brne	.+32     	; 0x4b8 <pattern3_blink+0x3a>
				ColUMN_LAST_PIN_PORT &= ~(1 << PINC0);
 498:	45 b3       	in	r20, 0x15	; 21
 49a:	4e 7f       	andi	r20, 0xFE	; 254
 49c:	45 bb       	out	0x15, r20	; 21
 49e:	4f ef       	ldi	r20, 0xFF	; 255
 4a0:	51 ee       	ldi	r21, 0xE1	; 225
 4a2:	64 e0       	ldi	r22, 0x04	; 4
 4a4:	41 50       	subi	r20, 0x01	; 1
 4a6:	50 40       	sbci	r21, 0x00	; 0
 4a8:	60 40       	sbci	r22, 0x00	; 0
 4aa:	e1 f7       	brne	.-8      	; 0x4a4 <pattern3_blink+0x26>
 4ac:	00 c0       	rjmp	.+0      	; 0x4ae <pattern3_blink+0x30>
 4ae:	00 00       	nop
				_delay_ms(100);
				ColUMN_LAST_PIN_PORT |= (1 << PINC0);
 4b0:	45 b3       	in	r20, 0x15	; 21
 4b2:	41 60       	ori	r20, 0x01	; 1
 4b4:	45 bb       	out	0x15, r20	; 21
				continue;
 4b6:	14 c0       	rjmp	.+40     	; 0x4e0 <pattern3_blink+0x62>
			}
			COLUMN_PORT = patterns3_blink[j][i];
 4b8:	f9 01       	movw	r30, r18
 4ba:	ee 0f       	add	r30, r30
 4bc:	ff 1f       	adc	r31, r31
 4be:	e2 0f       	add	r30, r18
 4c0:	f3 1f       	adc	r31, r19
 4c2:	eb 57       	subi	r30, 0x7B	; 123
 4c4:	ff 4f       	sbci	r31, 0xFF	; 255
 4c6:	e8 0f       	add	r30, r24
 4c8:	f9 1f       	adc	r31, r25
 4ca:	40 81       	ld	r20, Z
 4cc:	48 bb       	out	0x18, r20	; 24
 4ce:	4f ef       	ldi	r20, 0xFF	; 255
 4d0:	51 ee       	ldi	r21, 0xE1	; 225
 4d2:	64 e0       	ldi	r22, 0x04	; 4
 4d4:	41 50       	subi	r20, 0x01	; 1
 4d6:	50 40       	sbci	r21, 0x00	; 0
 4d8:	60 40       	sbci	r22, 0x00	; 0
 4da:	e1 f7       	brne	.-8      	; 0x4d4 <pattern3_blink+0x56>
 4dc:	00 c0       	rjmp	.+0      	; 0x4de <pattern3_blink+0x60>
 4de:	00 00       	nop

void pattern3_blink(void){
	for (int j = 0; j < 3; j++) {
		LAYER_PORT = 0b00000111;
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 4e0:	01 96       	adiw	r24, 0x01	; 1
 4e2:	83 30       	cpi	r24, 0x03	; 3
 4e4:	91 05       	cpc	r25, r1
 4e6:	9c f2       	brlt	.-90     	; 0x48e <pattern3_blink+0x10>
 4e8:	8f e9       	ldi	r24, 0x9F	; 159
 4ea:	9f e0       	ldi	r25, 0x0F	; 15
 4ec:	01 97       	sbiw	r24, 0x01	; 1
 4ee:	f1 f7       	brne	.-4      	; 0x4ec <pattern3_blink+0x6e>
 4f0:	00 c0       	rjmp	.+0      	; 0x4f2 <pattern3_blink+0x74>
 4f2:	00 00       	nop
	reset_pins();

}

void pattern3_blink(void){
	for (int j = 0; j < 3; j++) {
 4f4:	2f 5f       	subi	r18, 0xFF	; 255
 4f6:	3f 4f       	sbci	r19, 0xFF	; 255
 4f8:	23 30       	cpi	r18, 0x03	; 3
 4fa:	31 05       	cpc	r19, r1
 4fc:	1c f2       	brlt	.-122    	; 0x484 <pattern3_blink+0x6>
			COLUMN_PORT = patterns3_blink[j][i];
			_delay_ms(100); // Adjust the delay as needed for brightness
		}
		_delay_ms(1); // Adjust the delay to control animation speed
	}
	reset_pins();
 4fe:	0e 94 49 00 	call	0x92	; 0x92 <reset_pins>
 502:	08 95       	ret

00000504 <pattern4>:
	{0b11111011, 0b11111101, 0b11111110}, // Layer 2: All LEDs off
};


void pattern4(void){
	for (int j = 0; j < 3; j++) {
 504:	20 e0       	ldi	r18, 0x00	; 0
 506:	30 e0       	ldi	r19, 0x00	; 0
 508:	37 c0       	rjmp	.+110    	; 0x578 <pattern4+0x74>
		LAYER_PORT = 0b00000111;
 50a:	87 e0       	ldi	r24, 0x07	; 7
 50c:	8b bb       	out	0x1b, r24	; 27
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 50e:	80 e0       	ldi	r24, 0x00	; 0
 510:	90 e0       	ldi	r25, 0x00	; 0
 512:	27 c0       	rjmp	.+78     	; 0x562 <pattern4+0x5e>
			if(i == 0 && j == 0){
 514:	00 97       	sbiw	r24, 0x00	; 0
 516:	81 f4       	brne	.+32     	; 0x538 <pattern4+0x34>
 518:	21 15       	cp	r18, r1
 51a:	31 05       	cpc	r19, r1
 51c:	69 f4       	brne	.+26     	; 0x538 <pattern4+0x34>
				ColUMN_LAST_PIN_PORT &= ~(1 << PINC0);
 51e:	45 b3       	in	r20, 0x15	; 21
 520:	4e 7f       	andi	r20, 0xFE	; 254
 522:	45 bb       	out	0x15, r20	; 21
 524:	4f ef       	ldi	r20, 0xFF	; 255
 526:	51 ee       	ldi	r21, 0xE1	; 225
 528:	64 e0       	ldi	r22, 0x04	; 4
 52a:	41 50       	subi	r20, 0x01	; 1
 52c:	50 40       	sbci	r21, 0x00	; 0
 52e:	60 40       	sbci	r22, 0x00	; 0
 530:	e1 f7       	brne	.-8      	; 0x52a <pattern4+0x26>
 532:	00 c0       	rjmp	.+0      	; 0x534 <pattern4+0x30>
 534:	00 00       	nop
				_delay_ms(100);
				continue;
 536:	14 c0       	rjmp	.+40     	; 0x560 <pattern4+0x5c>
			}
			COLUMN_PORT = patterns4[j][i];
 538:	f9 01       	movw	r30, r18
 53a:	ee 0f       	add	r30, r30
 53c:	ff 1f       	adc	r31, r31
 53e:	e2 0f       	add	r30, r18
 540:	f3 1f       	adc	r31, r19
 542:	e0 56       	subi	r30, 0x60	; 96
 544:	ff 4f       	sbci	r31, 0xFF	; 255
 546:	e8 0f       	add	r30, r24
 548:	f9 1f       	adc	r31, r25
 54a:	40 81       	ld	r20, Z
 54c:	48 bb       	out	0x18, r20	; 24
 54e:	4f ef       	ldi	r20, 0xFF	; 255
 550:	51 ee       	ldi	r21, 0xE1	; 225
 552:	64 e0       	ldi	r22, 0x04	; 4
 554:	41 50       	subi	r20, 0x01	; 1
 556:	50 40       	sbci	r21, 0x00	; 0
 558:	60 40       	sbci	r22, 0x00	; 0
 55a:	e1 f7       	brne	.-8      	; 0x554 <pattern4+0x50>
 55c:	00 c0       	rjmp	.+0      	; 0x55e <pattern4+0x5a>
 55e:	00 00       	nop

void pattern4(void){
	for (int j = 0; j < 3; j++) {
		LAYER_PORT = 0b00000111;
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 560:	01 96       	adiw	r24, 0x01	; 1
 562:	83 30       	cpi	r24, 0x03	; 3
 564:	91 05       	cpc	r25, r1
 566:	b4 f2       	brlt	.-84     	; 0x514 <pattern4+0x10>
 568:	8f e9       	ldi	r24, 0x9F	; 159
 56a:	9f e0       	ldi	r25, 0x0F	; 15
 56c:	01 97       	sbiw	r24, 0x01	; 1
 56e:	f1 f7       	brne	.-4      	; 0x56c <pattern4+0x68>
 570:	00 c0       	rjmp	.+0      	; 0x572 <pattern4+0x6e>
 572:	00 00       	nop
	{0b11111011, 0b11111101, 0b11111110}, // Layer 2: All LEDs off
};


void pattern4(void){
	for (int j = 0; j < 3; j++) {
 574:	2f 5f       	subi	r18, 0xFF	; 255
 576:	3f 4f       	sbci	r19, 0xFF	; 255
 578:	23 30       	cpi	r18, 0x03	; 3
 57a:	31 05       	cpc	r19, r1
 57c:	34 f2       	brlt	.-116    	; 0x50a <pattern4+0x6>
			COLUMN_PORT = patterns4[j][i];
			_delay_ms(100); // Adjust the delay as needed for brightness
		}
		_delay_ms(1); // Adjust the delay to control animation speed
	}
	reset_pins();
 57e:	0e 94 49 00 	call	0x92	; 0x92 <reset_pins>
 582:	08 95       	ret

00000584 <pattern4_blink>:
}

void pattern4_blink(void){
	for (int j = 0; j < 3; j++) {
 584:	20 e0       	ldi	r18, 0x00	; 0
 586:	30 e0       	ldi	r19, 0x00	; 0
 588:	3a c0       	rjmp	.+116    	; 0x5fe <pattern4_blink+0x7a>
		LAYER_PORT = 0b00000111;
 58a:	87 e0       	ldi	r24, 0x07	; 7
 58c:	8b bb       	out	0x1b, r24	; 27
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 58e:	80 e0       	ldi	r24, 0x00	; 0
 590:	90 e0       	ldi	r25, 0x00	; 0
 592:	2a c0       	rjmp	.+84     	; 0x5e8 <pattern4_blink+0x64>
			if(i == 0 && j == 0){
 594:	00 97       	sbiw	r24, 0x00	; 0
 596:	99 f4       	brne	.+38     	; 0x5be <pattern4_blink+0x3a>
 598:	21 15       	cp	r18, r1
 59a:	31 05       	cpc	r19, r1
 59c:	81 f4       	brne	.+32     	; 0x5be <pattern4_blink+0x3a>
				ColUMN_LAST_PIN_PORT &= ~(1 << PINC0);
 59e:	45 b3       	in	r20, 0x15	; 21
 5a0:	4e 7f       	andi	r20, 0xFE	; 254
 5a2:	45 bb       	out	0x15, r20	; 21
 5a4:	4f ef       	ldi	r20, 0xFF	; 255
 5a6:	51 ee       	ldi	r21, 0xE1	; 225
 5a8:	64 e0       	ldi	r22, 0x04	; 4
 5aa:	41 50       	subi	r20, 0x01	; 1
 5ac:	50 40       	sbci	r21, 0x00	; 0
 5ae:	60 40       	sbci	r22, 0x00	; 0
 5b0:	e1 f7       	brne	.-8      	; 0x5aa <pattern4_blink+0x26>
 5b2:	00 c0       	rjmp	.+0      	; 0x5b4 <pattern4_blink+0x30>
 5b4:	00 00       	nop
				_delay_ms(100);
				ColUMN_LAST_PIN_PORT |= (1 << PINC0);
 5b6:	45 b3       	in	r20, 0x15	; 21
 5b8:	41 60       	ori	r20, 0x01	; 1
 5ba:	45 bb       	out	0x15, r20	; 21
				continue;
 5bc:	14 c0       	rjmp	.+40     	; 0x5e6 <pattern4_blink+0x62>
			}
			COLUMN_PORT = patterns4_blink[j][i];
 5be:	f9 01       	movw	r30, r18
 5c0:	ee 0f       	add	r30, r30
 5c2:	ff 1f       	adc	r31, r31
 5c4:	e2 0f       	add	r30, r18
 5c6:	f3 1f       	adc	r31, r19
 5c8:	e9 56       	subi	r30, 0x69	; 105
 5ca:	ff 4f       	sbci	r31, 0xFF	; 255
 5cc:	e8 0f       	add	r30, r24
 5ce:	f9 1f       	adc	r31, r25
 5d0:	40 81       	ld	r20, Z
 5d2:	48 bb       	out	0x18, r20	; 24
 5d4:	4f ef       	ldi	r20, 0xFF	; 255
 5d6:	51 ee       	ldi	r21, 0xE1	; 225
 5d8:	64 e0       	ldi	r22, 0x04	; 4
 5da:	41 50       	subi	r20, 0x01	; 1
 5dc:	50 40       	sbci	r21, 0x00	; 0
 5de:	60 40       	sbci	r22, 0x00	; 0
 5e0:	e1 f7       	brne	.-8      	; 0x5da <pattern4_blink+0x56>
 5e2:	00 c0       	rjmp	.+0      	; 0x5e4 <pattern4_blink+0x60>
 5e4:	00 00       	nop

void pattern4_blink(void){
	for (int j = 0; j < 3; j++) {
		LAYER_PORT = 0b00000111;
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 5e6:	01 96       	adiw	r24, 0x01	; 1
 5e8:	83 30       	cpi	r24, 0x03	; 3
 5ea:	91 05       	cpc	r25, r1
 5ec:	9c f2       	brlt	.-90     	; 0x594 <pattern4_blink+0x10>
 5ee:	8f e9       	ldi	r24, 0x9F	; 159
 5f0:	9f e0       	ldi	r25, 0x0F	; 15
 5f2:	01 97       	sbiw	r24, 0x01	; 1
 5f4:	f1 f7       	brne	.-4      	; 0x5f2 <pattern4_blink+0x6e>
 5f6:	00 c0       	rjmp	.+0      	; 0x5f8 <pattern4_blink+0x74>
 5f8:	00 00       	nop
	}
	reset_pins();
}

void pattern4_blink(void){
	for (int j = 0; j < 3; j++) {
 5fa:	2f 5f       	subi	r18, 0xFF	; 255
 5fc:	3f 4f       	sbci	r19, 0xFF	; 255
 5fe:	23 30       	cpi	r18, 0x03	; 3
 600:	31 05       	cpc	r19, r1
 602:	1c f2       	brlt	.-122    	; 0x58a <pattern4_blink+0x6>
			COLUMN_PORT = patterns4_blink[j][i];
			_delay_ms(100); // Adjust the delay as needed for brightness
		}
		_delay_ms(1); // Adjust the delay to control animation speed
	}
	reset_pins();
 604:	0e 94 49 00 	call	0x92	; 0x92 <reset_pins>
 608:	08 95       	ret

0000060a <pattern5>:
	{0b10111111, 0b11110111, 0b11101111}, // Layer 2: All LEDs off
};


void pattern5(void){
	for (int j = 0; j < 3; j++) {
 60a:	20 e0       	ldi	r18, 0x00	; 0
 60c:	30 e0       	ldi	r19, 0x00	; 0
 60e:	38 c0       	rjmp	.+112    	; 0x680 <pattern5+0x76>
		LAYER_PORT = 0b00000111;
 610:	87 e0       	ldi	r24, 0x07	; 7
 612:	8b bb       	out	0x1b, r24	; 27
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 614:	80 e0       	ldi	r24, 0x00	; 0
 616:	90 e0       	ldi	r25, 0x00	; 0
 618:	28 c0       	rjmp	.+80     	; 0x66a <pattern5+0x60>
			if(i == 1 && j == 1){
 61a:	81 30       	cpi	r24, 0x01	; 1
 61c:	91 05       	cpc	r25, r1
 61e:	81 f4       	brne	.+32     	; 0x640 <pattern5+0x36>
 620:	21 30       	cpi	r18, 0x01	; 1
 622:	31 05       	cpc	r19, r1
 624:	69 f4       	brne	.+26     	; 0x640 <pattern5+0x36>
				ColUMN_LAST_PIN_PORT &= ~(1 << PINC0);
 626:	45 b3       	in	r20, 0x15	; 21
 628:	4e 7f       	andi	r20, 0xFE	; 254
 62a:	45 bb       	out	0x15, r20	; 21
 62c:	4f ef       	ldi	r20, 0xFF	; 255
 62e:	51 ee       	ldi	r21, 0xE1	; 225
 630:	64 e0       	ldi	r22, 0x04	; 4
 632:	41 50       	subi	r20, 0x01	; 1
 634:	50 40       	sbci	r21, 0x00	; 0
 636:	60 40       	sbci	r22, 0x00	; 0
 638:	e1 f7       	brne	.-8      	; 0x632 <pattern5+0x28>
 63a:	00 c0       	rjmp	.+0      	; 0x63c <pattern5+0x32>
 63c:	00 00       	nop
				_delay_ms(100);
				continue;
 63e:	14 c0       	rjmp	.+40     	; 0x668 <pattern5+0x5e>
			}
			COLUMN_PORT = patterns5[j][i];
 640:	f9 01       	movw	r30, r18
 642:	ee 0f       	add	r30, r30
 644:	ff 1f       	adc	r31, r31
 646:	e2 0f       	add	r30, r18
 648:	f3 1f       	adc	r31, r19
 64a:	ee 54       	subi	r30, 0x4E	; 78
 64c:	ff 4f       	sbci	r31, 0xFF	; 255
 64e:	e8 0f       	add	r30, r24
 650:	f9 1f       	adc	r31, r25
 652:	40 81       	ld	r20, Z
 654:	48 bb       	out	0x18, r20	; 24
 656:	4f ef       	ldi	r20, 0xFF	; 255
 658:	51 ee       	ldi	r21, 0xE1	; 225
 65a:	64 e0       	ldi	r22, 0x04	; 4
 65c:	41 50       	subi	r20, 0x01	; 1
 65e:	50 40       	sbci	r21, 0x00	; 0
 660:	60 40       	sbci	r22, 0x00	; 0
 662:	e1 f7       	brne	.-8      	; 0x65c <pattern5+0x52>
 664:	00 c0       	rjmp	.+0      	; 0x666 <pattern5+0x5c>
 666:	00 00       	nop

void pattern5(void){
	for (int j = 0; j < 3; j++) {
		LAYER_PORT = 0b00000111;
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 668:	01 96       	adiw	r24, 0x01	; 1
 66a:	83 30       	cpi	r24, 0x03	; 3
 66c:	91 05       	cpc	r25, r1
 66e:	ac f2       	brlt	.-86     	; 0x61a <pattern5+0x10>
 670:	8f e9       	ldi	r24, 0x9F	; 159
 672:	9f e0       	ldi	r25, 0x0F	; 15
 674:	01 97       	sbiw	r24, 0x01	; 1
 676:	f1 f7       	brne	.-4      	; 0x674 <pattern5+0x6a>
 678:	00 c0       	rjmp	.+0      	; 0x67a <pattern5+0x70>
 67a:	00 00       	nop
	{0b10111111, 0b11110111, 0b11101111}, // Layer 2: All LEDs off
};


void pattern5(void){
	for (int j = 0; j < 3; j++) {
 67c:	2f 5f       	subi	r18, 0xFF	; 255
 67e:	3f 4f       	sbci	r19, 0xFF	; 255
 680:	23 30       	cpi	r18, 0x03	; 3
 682:	31 05       	cpc	r19, r1
 684:	2c f2       	brlt	.-118    	; 0x610 <pattern5+0x6>
			COLUMN_PORT = patterns5[j][i];
			_delay_ms(100); // Adjust the delay as needed for brightness
		}
		_delay_ms(1); // Adjust the delay to control animation speed
	}
	reset_pins();
 686:	0e 94 49 00 	call	0x92	; 0x92 <reset_pins>
 68a:	08 95       	ret

0000068c <pattern5_blink>:
}

void pattern5_blink(void){
	for (int j = 0; j < 3; j++) {
 68c:	20 e0       	ldi	r18, 0x00	; 0
 68e:	30 e0       	ldi	r19, 0x00	; 0
 690:	3b c0       	rjmp	.+118    	; 0x708 <pattern5_blink+0x7c>
		LAYER_PORT = 0b00000111;
 692:	87 e0       	ldi	r24, 0x07	; 7
 694:	8b bb       	out	0x1b, r24	; 27
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 696:	80 e0       	ldi	r24, 0x00	; 0
 698:	90 e0       	ldi	r25, 0x00	; 0
 69a:	2b c0       	rjmp	.+86     	; 0x6f2 <pattern5_blink+0x66>
			if(i == 1 && j == 1){
 69c:	81 30       	cpi	r24, 0x01	; 1
 69e:	91 05       	cpc	r25, r1
 6a0:	99 f4       	brne	.+38     	; 0x6c8 <pattern5_blink+0x3c>
 6a2:	21 30       	cpi	r18, 0x01	; 1
 6a4:	31 05       	cpc	r19, r1
 6a6:	81 f4       	brne	.+32     	; 0x6c8 <pattern5_blink+0x3c>
				ColUMN_LAST_PIN_PORT &= ~(1 << PINC0);
 6a8:	45 b3       	in	r20, 0x15	; 21
 6aa:	4e 7f       	andi	r20, 0xFE	; 254
 6ac:	45 bb       	out	0x15, r20	; 21
 6ae:	4f ef       	ldi	r20, 0xFF	; 255
 6b0:	51 ee       	ldi	r21, 0xE1	; 225
 6b2:	64 e0       	ldi	r22, 0x04	; 4
 6b4:	41 50       	subi	r20, 0x01	; 1
 6b6:	50 40       	sbci	r21, 0x00	; 0
 6b8:	60 40       	sbci	r22, 0x00	; 0
 6ba:	e1 f7       	brne	.-8      	; 0x6b4 <pattern5_blink+0x28>
 6bc:	00 c0       	rjmp	.+0      	; 0x6be <pattern5_blink+0x32>
 6be:	00 00       	nop
				_delay_ms(100);
				ColUMN_LAST_PIN_PORT |= (1 << PINC0);
 6c0:	45 b3       	in	r20, 0x15	; 21
 6c2:	41 60       	ori	r20, 0x01	; 1
 6c4:	45 bb       	out	0x15, r20	; 21
				continue;
 6c6:	14 c0       	rjmp	.+40     	; 0x6f0 <pattern5_blink+0x64>
			}
			COLUMN_PORT = patterns5_blink[j][i];
 6c8:	f9 01       	movw	r30, r18
 6ca:	ee 0f       	add	r30, r30
 6cc:	ff 1f       	adc	r31, r31
 6ce:	e2 0f       	add	r30, r18
 6d0:	f3 1f       	adc	r31, r19
 6d2:	e7 55       	subi	r30, 0x57	; 87
 6d4:	ff 4f       	sbci	r31, 0xFF	; 255
 6d6:	e8 0f       	add	r30, r24
 6d8:	f9 1f       	adc	r31, r25
 6da:	40 81       	ld	r20, Z
 6dc:	48 bb       	out	0x18, r20	; 24
 6de:	4f ef       	ldi	r20, 0xFF	; 255
 6e0:	51 ee       	ldi	r21, 0xE1	; 225
 6e2:	64 e0       	ldi	r22, 0x04	; 4
 6e4:	41 50       	subi	r20, 0x01	; 1
 6e6:	50 40       	sbci	r21, 0x00	; 0
 6e8:	60 40       	sbci	r22, 0x00	; 0
 6ea:	e1 f7       	brne	.-8      	; 0x6e4 <pattern5_blink+0x58>
 6ec:	00 c0       	rjmp	.+0      	; 0x6ee <pattern5_blink+0x62>
 6ee:	00 00       	nop

void pattern5_blink(void){
	for (int j = 0; j < 3; j++) {
		LAYER_PORT = 0b00000111;
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 6f0:	01 96       	adiw	r24, 0x01	; 1
 6f2:	83 30       	cpi	r24, 0x03	; 3
 6f4:	91 05       	cpc	r25, r1
 6f6:	94 f2       	brlt	.-92     	; 0x69c <pattern5_blink+0x10>
 6f8:	8f e9       	ldi	r24, 0x9F	; 159
 6fa:	9f e0       	ldi	r25, 0x0F	; 15
 6fc:	01 97       	sbiw	r24, 0x01	; 1
 6fe:	f1 f7       	brne	.-4      	; 0x6fc <pattern5_blink+0x70>
 700:	00 c0       	rjmp	.+0      	; 0x702 <pattern5_blink+0x76>
 702:	00 00       	nop
	}
	reset_pins();
}

void pattern5_blink(void){
	for (int j = 0; j < 3; j++) {
 704:	2f 5f       	subi	r18, 0xFF	; 255
 706:	3f 4f       	sbci	r19, 0xFF	; 255
 708:	23 30       	cpi	r18, 0x03	; 3
 70a:	31 05       	cpc	r19, r1
 70c:	14 f2       	brlt	.-124    	; 0x692 <pattern5_blink+0x6>
			COLUMN_PORT = patterns5_blink[j][i];
			_delay_ms(100); // Adjust the delay as needed for brightness
		}
		_delay_ms(1); // Adjust the delay to control animation speed
	}
	reset_pins();
 70e:	0e 94 49 00 	call	0x92	; 0x92 <reset_pins>
 712:	08 95       	ret

00000714 <pattern6>:
	{0b11111011, 0b11111101, 0b11111110}, // Layer 2: All LEDs off
};


void pattern6(void){
	for (int j = 0; j < 3; j++) {
 714:	20 e0       	ldi	r18, 0x00	; 0
 716:	30 e0       	ldi	r19, 0x00	; 0
 718:	38 c0       	rjmp	.+112    	; 0x78a <pattern6+0x76>
		LAYER_PORT = 0b00000111;
 71a:	87 e0       	ldi	r24, 0x07	; 7
 71c:	8b bb       	out	0x1b, r24	; 27
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 71e:	80 e0       	ldi	r24, 0x00	; 0
 720:	90 e0       	ldi	r25, 0x00	; 0
 722:	28 c0       	rjmp	.+80     	; 0x774 <pattern6+0x60>
			if(i == 1 && j == 1){
 724:	81 30       	cpi	r24, 0x01	; 1
 726:	91 05       	cpc	r25, r1
 728:	81 f4       	brne	.+32     	; 0x74a <pattern6+0x36>
 72a:	21 30       	cpi	r18, 0x01	; 1
 72c:	31 05       	cpc	r19, r1
 72e:	69 f4       	brne	.+26     	; 0x74a <pattern6+0x36>
				ColUMN_LAST_PIN_PORT &= ~(1 << PINC0);
 730:	45 b3       	in	r20, 0x15	; 21
 732:	4e 7f       	andi	r20, 0xFE	; 254
 734:	45 bb       	out	0x15, r20	; 21
 736:	4f ef       	ldi	r20, 0xFF	; 255
 738:	51 ee       	ldi	r21, 0xE1	; 225
 73a:	64 e0       	ldi	r22, 0x04	; 4
 73c:	41 50       	subi	r20, 0x01	; 1
 73e:	50 40       	sbci	r21, 0x00	; 0
 740:	60 40       	sbci	r22, 0x00	; 0
 742:	e1 f7       	brne	.-8      	; 0x73c <pattern6+0x28>
 744:	00 c0       	rjmp	.+0      	; 0x746 <pattern6+0x32>
 746:	00 00       	nop
				_delay_ms(100);
				continue;
 748:	14 c0       	rjmp	.+40     	; 0x772 <pattern6+0x5e>
			}
			COLUMN_PORT = patterns6[j][i];
 74a:	f9 01       	movw	r30, r18
 74c:	ee 0f       	add	r30, r30
 74e:	ff 1f       	adc	r31, r31
 750:	e2 0f       	add	r30, r18
 752:	f3 1f       	adc	r31, r19
 754:	ec 53       	subi	r30, 0x3C	; 60
 756:	ff 4f       	sbci	r31, 0xFF	; 255
 758:	e8 0f       	add	r30, r24
 75a:	f9 1f       	adc	r31, r25
 75c:	40 81       	ld	r20, Z
 75e:	48 bb       	out	0x18, r20	; 24
 760:	4f ef       	ldi	r20, 0xFF	; 255
 762:	51 ee       	ldi	r21, 0xE1	; 225
 764:	64 e0       	ldi	r22, 0x04	; 4
 766:	41 50       	subi	r20, 0x01	; 1
 768:	50 40       	sbci	r21, 0x00	; 0
 76a:	60 40       	sbci	r22, 0x00	; 0
 76c:	e1 f7       	brne	.-8      	; 0x766 <pattern6+0x52>
 76e:	00 c0       	rjmp	.+0      	; 0x770 <pattern6+0x5c>
 770:	00 00       	nop

void pattern6(void){
	for (int j = 0; j < 3; j++) {
		LAYER_PORT = 0b00000111;
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 772:	01 96       	adiw	r24, 0x01	; 1
 774:	83 30       	cpi	r24, 0x03	; 3
 776:	91 05       	cpc	r25, r1
 778:	ac f2       	brlt	.-86     	; 0x724 <pattern6+0x10>
 77a:	8f e9       	ldi	r24, 0x9F	; 159
 77c:	9f e0       	ldi	r25, 0x0F	; 15
 77e:	01 97       	sbiw	r24, 0x01	; 1
 780:	f1 f7       	brne	.-4      	; 0x77e <pattern6+0x6a>
 782:	00 c0       	rjmp	.+0      	; 0x784 <pattern6+0x70>
 784:	00 00       	nop
	{0b11111011, 0b11111101, 0b11111110}, // Layer 2: All LEDs off
};


void pattern6(void){
	for (int j = 0; j < 3; j++) {
 786:	2f 5f       	subi	r18, 0xFF	; 255
 788:	3f 4f       	sbci	r19, 0xFF	; 255
 78a:	23 30       	cpi	r18, 0x03	; 3
 78c:	31 05       	cpc	r19, r1
 78e:	2c f2       	brlt	.-118    	; 0x71a <pattern6+0x6>
			COLUMN_PORT = patterns6[j][i];
			_delay_ms(100); // Adjust the delay as needed for brightness
		}
		_delay_ms(1); // Adjust the delay to control animation speed
	}
	reset_pins();
 790:	0e 94 49 00 	call	0x92	; 0x92 <reset_pins>
 794:	08 95       	ret

00000796 <pattern6_blink>:
}

void pattern6_blink(void){
	for (int j = 0; j < 3; j++) {
 796:	20 e0       	ldi	r18, 0x00	; 0
 798:	30 e0       	ldi	r19, 0x00	; 0
 79a:	3b c0       	rjmp	.+118    	; 0x812 <__DATA_REGION_LENGTH__+0x12>
		LAYER_PORT = 0b00000111;
 79c:	87 e0       	ldi	r24, 0x07	; 7
 79e:	8b bb       	out	0x1b, r24	; 27
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 7a0:	80 e0       	ldi	r24, 0x00	; 0
 7a2:	90 e0       	ldi	r25, 0x00	; 0
 7a4:	2b c0       	rjmp	.+86     	; 0x7fc <pattern6_blink+0x66>
			if(i == 1 && j == 1){
 7a6:	81 30       	cpi	r24, 0x01	; 1
 7a8:	91 05       	cpc	r25, r1
 7aa:	99 f4       	brne	.+38     	; 0x7d2 <pattern6_blink+0x3c>
 7ac:	21 30       	cpi	r18, 0x01	; 1
 7ae:	31 05       	cpc	r19, r1
 7b0:	81 f4       	brne	.+32     	; 0x7d2 <pattern6_blink+0x3c>
				ColUMN_LAST_PIN_PORT &= ~(1 << PINC0);
 7b2:	45 b3       	in	r20, 0x15	; 21
 7b4:	4e 7f       	andi	r20, 0xFE	; 254
 7b6:	45 bb       	out	0x15, r20	; 21
 7b8:	4f ef       	ldi	r20, 0xFF	; 255
 7ba:	51 ee       	ldi	r21, 0xE1	; 225
 7bc:	64 e0       	ldi	r22, 0x04	; 4
 7be:	41 50       	subi	r20, 0x01	; 1
 7c0:	50 40       	sbci	r21, 0x00	; 0
 7c2:	60 40       	sbci	r22, 0x00	; 0
 7c4:	e1 f7       	brne	.-8      	; 0x7be <pattern6_blink+0x28>
 7c6:	00 c0       	rjmp	.+0      	; 0x7c8 <pattern6_blink+0x32>
 7c8:	00 00       	nop
				_delay_ms(100);
				ColUMN_LAST_PIN_PORT |= (1 << PINC0);
 7ca:	45 b3       	in	r20, 0x15	; 21
 7cc:	41 60       	ori	r20, 0x01	; 1
 7ce:	45 bb       	out	0x15, r20	; 21
				continue;
 7d0:	14 c0       	rjmp	.+40     	; 0x7fa <pattern6_blink+0x64>
			}
			COLUMN_PORT = patterns6_blink[j][i];
 7d2:	f9 01       	movw	r30, r18
 7d4:	ee 0f       	add	r30, r30
 7d6:	ff 1f       	adc	r31, r31
 7d8:	e2 0f       	add	r30, r18
 7da:	f3 1f       	adc	r31, r19
 7dc:	e5 54       	subi	r30, 0x45	; 69
 7de:	ff 4f       	sbci	r31, 0xFF	; 255
 7e0:	e8 0f       	add	r30, r24
 7e2:	f9 1f       	adc	r31, r25
 7e4:	40 81       	ld	r20, Z
 7e6:	48 bb       	out	0x18, r20	; 24
 7e8:	4f ef       	ldi	r20, 0xFF	; 255
 7ea:	51 ee       	ldi	r21, 0xE1	; 225
 7ec:	64 e0       	ldi	r22, 0x04	; 4
 7ee:	41 50       	subi	r20, 0x01	; 1
 7f0:	50 40       	sbci	r21, 0x00	; 0
 7f2:	60 40       	sbci	r22, 0x00	; 0
 7f4:	e1 f7       	brne	.-8      	; 0x7ee <pattern6_blink+0x58>
 7f6:	00 c0       	rjmp	.+0      	; 0x7f8 <pattern6_blink+0x62>
 7f8:	00 00       	nop

void pattern6_blink(void){
	for (int j = 0; j < 3; j++) {
		LAYER_PORT = 0b00000111;
		// Output the pattern for the selected layer
		for (int i = 0; i < 3; i++) {
 7fa:	01 96       	adiw	r24, 0x01	; 1
 7fc:	83 30       	cpi	r24, 0x03	; 3
 7fe:	91 05       	cpc	r25, r1
 800:	94 f2       	brlt	.-92     	; 0x7a6 <pattern6_blink+0x10>
 802:	8f e9       	ldi	r24, 0x9F	; 159
 804:	9f e0       	ldi	r25, 0x0F	; 15
 806:	01 97       	sbiw	r24, 0x01	; 1
 808:	f1 f7       	brne	.-4      	; 0x806 <__DATA_REGION_LENGTH__+0x6>
 80a:	00 c0       	rjmp	.+0      	; 0x80c <__DATA_REGION_LENGTH__+0xc>
 80c:	00 00       	nop
	}
	reset_pins();
}

void pattern6_blink(void){
	for (int j = 0; j < 3; j++) {
 80e:	2f 5f       	subi	r18, 0xFF	; 255
 810:	3f 4f       	sbci	r19, 0xFF	; 255
 812:	23 30       	cpi	r18, 0x03	; 3
 814:	31 05       	cpc	r19, r1
 816:	14 f2       	brlt	.-124    	; 0x79c <pattern6_blink+0x6>
			COLUMN_PORT = patterns6_blink[j][i];
			_delay_ms(100); // Adjust the delay as needed for brightness
		}
		_delay_ms(1); // Adjust the delay to control animation speed
	}
	reset_pins();
 818:	0e 94 49 00 	call	0x92	; 0x92 <reset_pins>
 81c:	08 95       	ret

0000081e <_exit>:
 81e:	f8 94       	cli

00000820 <__stop_program>:
 820:	ff cf       	rjmp	.-2      	; 0x820 <__stop_program>
